/**
 * # Matrix.js - v0.0.9
 *
 * Copyright (c) 2017 Kohei Katada.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

const Matrix = () => {
	'use strict';

	/*
	 # util
	 */
	const util = {
		/**
		 * # 数値かどうかの真偽値を返す
		 * @param num
		 * @returns {boolean}
		 */
		isNumber(num) {
			return typeof num === 'number' && isFinite(num);
		},

		/**
		 * # 配列かどうかの真偽値を返す
		 * @param arr
		 * @returns {boolean}
		 */
		isArray(arr) {
			return Object.prototype.toString.call(arr) === '[object Array]';
		},

		/**
		 * # 関数かどうかの真偽値を返す
		 * @param fn
		 * @returns {boolean}
		 */
		isFunction(fn, notArrow) {
			return Object.prototype.toString.call(fn) === '[object Function]' && (!notArrow || 'prototype' in fn);
		}
	};

	/*
	 # math
	 */
	const math = {
		/**
		 * # 正規乱数生成
		 * @param mean
		 * @param sd
		 * @returns {*}
		 */
		rnorm(mean, sd) {
			const x = Math.random();
			const y = Math.random();
			return mean + sd * Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);
		},

		/**
		 * # ブロードキャスト
		 * @param x
		 * @param y
		 * @returns {[*,*]}
		 */
		broadcast(x, y) {
			// xとyの両方がスカラ値の場合
			if ( (!util.isArray(x)) && (!util.isArray(y)) ) {
				return [x, y];
			}
			// xがスカラ値の場合
			if ( (!util.isArray(x)) ) {
				x = [x];
			}
			// yがスカラ値の場合
			if ( (!util.isArray(y)) ) {
				y = [y];
			}
			return [x, y];
		},

		/**
		 * # 足し算
		 * @param x
		 * @param y
		 * @returns {*}
		 */
		plus(x, y) {
			if (util.isArray(x[0]) && util.isArray(y[0])) {
				let bc = this.matrix.broadcast(x, y, 0);
				x = bc[0];
				y = bc[1];
				return this.matrix.plus(x, y);
			} else if (util.isArray(x) && util.isArray(y)) {
				let bc = this.arr.broadcast(x, y, 0);
				x = bc[0];
				y = bc[1];
				return this.arr.plus(x, y);
			} else if (!util.isArray(x) && !util.isArray(y)) {
				return x + y;
			} else {
				let bc = this.broadcast(x, y);
				x = bc[0];
				y = bc[1];
				return this.plus(x, y);
			}
		},

		/**
		 * # 引き算
		 * @param x
		 * @param y
		 * @returns {number}
		 */
		minus(x, y) {
			if (util.isArray(x[0]) && util.isArray(y[0])) {
				let bc = this.matrix.broadcast(x, y, 0);
				x = bc[0];
				y = bc[1];
				return this.matrix.minus(x, y);
			} else if (util.isArray(x) && util.isArray(y)) {
				let bc = this.arr.broadcast(x, y, 0);
				x = bc[0];
				y = bc[1];
				return this.arr.minus(x, y);
			} else if (!util.isArray(x) && !util.isArray(y)) {
				return x - y;
			} else {
				let bc = this.broadcast(x, y);
				x = bc[0];
				y = bc[1];
				return this.minus(x, y);
			}
		},

		/**
		 * # 掛け算
		 * @param x
		 * @param y
		 * @returns {number}
		 */
		multi(x, y) {
			if (util.isArray(x[0]) && util.isArray(y[0])) {
				let bc = this.matrix.broadcast(x, y, 1);
				x = bc[0];
				y = bc[1];
				return this.matrix.multi(x, y);
			} else if (util.isArray(x) && util.isArray(y)) {
				let bc = this.arr.broadcast(x, y, 1);
				x = bc[0];
				y = bc[1];
				return this.arr.multi(x, y);
			} else if (!util.isArray(x) && !util.isArray(y)) {
				return x * y;
			} else {
				let bc = this.broadcast(x, y);
				x = bc[0];
				y = bc[1];
				return this.multi(x, y);
			}
		},

		/**
		 * # 割り算
		 * @param x
		 * @param y
		 * @returns {number}
		 */
		divi(x, y) {
			if (util.isArray(x[0]) && util.isArray(y[0])) {
				let bc = this.matrix.broadcast(x, y, 1);
				x = bc[0];
				y = bc[1];
				return this.matrix.divi(x, y);
			} else if (util.isArray(x) && util.isArray(y)) {
				let bc = this.arr.broadcast(x, y, 1);
				x = bc[0];
				y = bc[1];
				return this.arr.divi(x, y);
			} else if (!util.isArray(x) && !util.isArray(y)) {
				return x / y;
			} else {
				let bc = this.broadcast(x, y);
				x = bc[0];
				y = bc[1];
				return this.divi(x, y);
			}
		},

		/**
		 * # n次元配列の総和を求める
		 * @param x
		 * @returns {*}
		 */
		sum(x) {
			if (util.isArray(x[0])) {
				return this.matrix.sum(x);
			}
			if (util.isArray(x)) {
				return this.arr.sum(x);
			}
			return x;
		},

		/**
		 * # n次元配列中の最大値のインデックスを取得
		 * @param x
		 * @returns {*}
		 */
		maxIdx(x) {
			if (util.isArray(x[0])) {
				return this.matrix.maxIdx(x);
			}
			if (util.isArray(x)) {
				return this.arr.maxIdx(x);
			}
			return x;
		},

		/**
		 * # 2つの配列の同じインデックスの要素の値が同じだった場合に、そのカウント数を取得する(多次元対応版)
		 * @param x
		 * @param y
		 * @returns {*}
		 */
		matchCount(x, y) {
			if (util.isArray(x[0]) && util.isArray(y[0])) {
				return this.matrix.matchCount(x, y);
			}
			if (util.isArray(x) && util.isArray(y)) {
				return this.arr.matchCount(x, y);
			}
			if (x === y) {
				return 1;
			}
			return 0;
		},

		/**
		 * # n次元配列の形状を返す
		 * @param arr
		 * @returns {[*,*]}
		 */
		shape(arr) {
			let row, col;
			if (util.isArray(arr[0])) {
				row = arr.length;
				col = arr[0].length;
			} else if (util.isArray(arr)) {
				row = 1;
				col = arr.length;
			} else {
				row = 0;
				col = 0;
			}
			return [row, col];
		},

		/**
		 * # 累乗する
		 * @param x
		 * @param n
		 * @returns {*}
		 */
		pow(x, n) {
			if (util.isArray(x[0]) && util.isArray(n[0])) {
				let bc = this.matrix.broadcast(x, n, 0);
				x = bc[0];
				n = bc[1];
				return this.matrix.pow(x, n);
			} else if (util.isArray(x) && util.isArray(n)) {
				let bc = this.arr.broadcast(x, n, 0);
				x = bc[0];
				n = bc[1];
				return this.arr.pow(x, n);
			} else if (!util.isArray(x) && !util.isArray(n)) {
				return Math.pow(x, n);
			} else {
				let bc = this.broadcast(x, n);
				x = bc[0];
				n = bc[1];
				return this.pow(x, n);
			}
		},

		/**
		 * # Ex を返す.(自然対数の底であるネイピア数（オイラー数))
		 * @param x
		 * @returns {*}
		 */
		exp(x) {
			if (util.isArray(x[0])) {
				return this.matrix.exp(x);
			}
			if (util.isArray(x)) {
				return this.arr.exp(x);
			}
			return Math.exp(x);
		},

		/**
		 * # 自然対数 (底は e) を返す.
		 * @param x
		 * @returns {*}
		 */
		log(x) {
			if (util.isArray(x[0])) {
				return this.matrix.log(x);
			}
			if (util.isArray(x)) {
				return this.arr.log(x);
			}
			return Math.log(x);
		},

		/**
		 * # 一番大きい数値を返す
		 * @param x
		 * @param y
		 * @returns {number}
		 */
		max(x, y) {
			if (util.isArray(x[0])) {
				return this.matrix.max(x);
			}
			if (util.isArray(x)) {
				return this.arr.max(x);
			}
			return Math.max(x, y);
		},

		/*
		 # math.arr
		 */
		arr: {
			/**
			 * # 1次元配列生成
			 * @param x {Number}
			 * @param v {*} # 配列の各要素を初期化する値(関数だった場合は関数の戻り値で初期化)
			 * @returns {Array}
			 */
			create(x, v) {
				let r = [];
				for (let i=0,l=x; i<l; i+=1) {
					r[i] = util.isFunction(v) ? v() : v;
				}
				return r;
			},

			/**
			 * # ブロードキャスト(配列の形状を合わせる)
			 * @param x
			 * @param y
			 * @param v
			 * @returns {[*,*]}
			 */
			broadcast(x, y, v) {
				let r = [];
				let flag = false;

				// 次元が同じ場合
				if (x.length === y.length) {
					return [x, y];
				} else if (x.length === 1) {
					flag = true;
					for (let i=0,l=y.length; i<l; i+=1) {
						r[i] = x[0];
					}
				} else if (y.length === 1) {
					flag = false;
					for (let i=0,l=x.length; i<l; i+=1) {
						r[i] = y[0];
					}
				} else {
					// 次元が異なる場合
					if (x[0].length === y[0].length) {
						if (x.length < y.length) {
							flag = true;
							for (let i=0,l=y.length; i<l; i+=1) {
								r[i] = x[i];
								if (i > x.length-1) {
									r[i] = v;
								}
							}
						} else if (x.length > y.length) {
							flag = false;
							for (let i=0,l=x.length; i<l; i+=1) {
								r[i] = y[i];
								if (i > y.length-1) {
									r[i] = v;
								}
							}
						} else {
							throw new Error('ブロードキャストできません.');
						}
					} else if ((math.shape(x)[0]===1)) { // x項が1次元配列だった場合にデータを整形
						flag = true;
						for (let i=0,l=y.length; i<l; i+=1) {
							r[i] = x;
						}
					} else if ((math.shape(y)[0]===1)) { // y項が1次元配列だった場合にデータを整形
						flag = false;
						for (let i=0,l=x.length; i<l; i+=1) {
							r[i] = y;
						}
					} else {
						throw new Error('ブロードキャストできません.');
					}
				}

				if (flag) {
					x = r;
				} else {
					y = r;
				}

				return [x, y];
			},

			/**
			 * # 1次元配列同士の足し算
			 * @param x
			 * @param y
			 * @returns {Array}
			 */
			plus(x, y) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.plus(x[i], y[i]);
				}
				return r;
			},

			/**
			 * # 1次元配列同士の引き算 (x - y)
			 * @param x
			 * @param y
			 * @returns {Array}
			 */
			minus(x, y) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.minus(x[i], y[i]);
				}
				return r;
			},

			/**
			 * # 1次元配列同士の掛け算
			 * @param x
			 * @param y
			 * @returns {Array}
			 */
			multi(x, y) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.multi(x[i], y[i]);
				}
				return r;
			},

			/**
			 * # 1次元配列同士の割り算 (x / y)
			 * @param x
			 * @param y
			 * @returns {Array}
			 */
			divi(x, y) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.divi(x[i], y[i]);
				}
				return r;
			},

			/**
			 * # 1次元配列の総和を求める
			 * @param x
			 * @returns {number}
			 */
			sum(x) {
				let r = 0;
				for (let i=0,l=x.length; i<l; i+=1) {
					r = math.plus(r, x[i]);
				}
				return r;
			},

			/**
			 * # 配列中の最大値のインデックスを取得
			 * @param x
			 * @returns {Number|number}
			 */
			maxIdx(x) {
				return x.indexOf(Math.max.apply(null, x));
			},

			/**
			 * # 2つの配列の同じインデックスの要素の値が同じだった場合に、そのカウント数を取得する
			 * @param x
			 * @param y
			 * @returns {number}
			 */
			matchCount(x, y) {
				let r = 0;
				for (let i=0,l=x.length; i<l; i+=1) {
					if (x[i] === y[i]) {
						r = math.plus(r, 1);
					}
				}
				return r;
			},

			/**
			 * # 累乗する
			 * @param x
			 * @param n
			 * @returns {*}
			 */
			pow(x, n) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.pow(x[i], n[i]);
				}
				return r;
			},

			/**
			 * # Ex を返す.(自然対数の底であるネイピア数（オイラー数))
			 * @param x
			 * @returns {*}
			 */
			exp(x) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.exp(x[i]);
				}
				return r;
			},

			/**
			 * # 自然対数 (底は e) を返す.
			 * @param x
			 * @returns {*}
			 */
			log(x) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.log(x[i]);
				}
				return r;
			},

			/**
			 * # 一番大きい数値を返す
			 * @param x
			 * @returns {number}
			 */
			max(x) {
				return Math.max.apply(null, x);
			},

			/**
			 * # unit単位の、minSizeからmaxSizeまでの数の1次元配列を生成
			 * @param minSize
			 * @param maxSize
			 * @param unit
			 * @param callback # 出来上がった配列に適用可能な関数
			 * @returns {Array}
			 */
			arange(minSize, maxSize, unit, callback) {
				// 初期化
				let arr = [];

				// unit引数がないのに、maxSize引数がある場合
				if (!unit && !!maxSize) {
					throw new Error('第三引数の段数が指定されていないため計算できません.');
				}

				// 引数がminSizeだけの場合
				if (!unit && !maxSize && !!minSize) {
					// 引数がminSizeだけで、負の値だった場合
					if (minSize < 0) {
						throw new Error('負の値を指定するときは第二引数に範囲の最大値、第三引数に段数を指定してください.');
					}
					// 引数がminSizeだけで、正の値だった場合
					for (let i=0,l=minSize; i<l; i+=1) {
						arr[i] = i;
					}
				}

				// 引数が全てある場合
				if (!!unit) {
					if (maxSize <= minSize) {
						throw new Error('第二引数の値は第一引数の値より大きい値を指定してください.');
					}

					let len = math.minus(maxSize, minSize);
					for (let i=0,l=math.divi(len, unit); i<l; i+=1) {
						arr[i] = math.plus(minSize, math.multi(unit, i));
					}
				}

				// コールバック関数がある場合
				if (!!callback) {
					for (let i=0,l=arr.length; i<l; i+=1) {
						arr[i] = callback(arr[i]);
					}
					return arr;
				}

				return arr;
			}
		},

		/*
		 # math.matrix
		 */
		matrix: {
			/**
			 * # 行列を生成
			 * @param x {Array|Number}
			 * @param y {Number}
			 * @param v {*} # 行列の各要素を初期化する値(関数だった場合は関数の戻り値で初期化)
			 * @returns {*}
			 */
			create(x, y, v) {
				let r1;

				if (util.isArray(x)) {
					if (!util.isArray(x[0])) {
						r1 = [x];
					} else {
						r1 = x;
					}
				}

				let r2 = [];

				for (let i=0,l=x; i<l; i+=1) {
					r2[i] = (() => {
						return math.arr.create(y, v);
					})();
				}

				let r;

				if (!!r1) {
					r = r1;
				} else {
					r = r2;
				}

				return r;
			},

			/**
			 * # ブロードキャスト(行列の形状を合わせる)
			 * @param x
			 * @param y
			 * @param v
			 * @returns {[*,*]}
			 */
			broadcast(x, y, v) {
				return math.arr.broadcast(x, y, v);
			},

			/**
			 * # 行列の足し算
			 * @param m1
			 * @param m2
			 * @returns {Array}
			 */
			plus(m1, m2) {
				let r = [];
				for (let i=0,l=m1.length; i<l; i+=1) {
					r[i] = math.arr.plus(m1[i], m2[i]);
				}
				return r;
			},

			/**
			 * # 行列の引き算
			 * @param m1
			 * @param m2
			 * @returns {Array}
			 */
			minus(m1, m2) {
				let r = [];
				for (let i=0,l=m1.length; i<l; i+=1) {
					r[i] = math.arr.minus(m1[i], m2[i]);
				}
				return r;
			},

			/**
			 * # 行列の掛け算
			 * @param m1
			 * @param m2
			 * @returns {Array}
			 */
			multi(m1, m2) {
				let r = [];
				for (let i=0,l=m1.length; i<l; i+=1) {
					r[i] = math.arr.multi(m1[i], m2[i]);
				}
				return r;
			},

			/**
			 * # 行列の割り算
			 * @param m1
			 * @param m2
			 * @returns {Array}
			 */
			divi(m1, m2) {
				let r = [];
				for (let i=0,l=m1.length; i<l; i+=1) {
					r[i] = math.arr.divi(m1[i], m2[i]);
				}
				return r;
			},

			/**
			 * # 行列中のそれぞれの総和を求める
			 * @param matrix
			 * @returns {Array}
			 */
			sum(matrix) {
				let r = [];
				for (let i=0,l=matrix.length; i<l; i+=1) {
					r[i] = math.arr.sum(matrix[i]);
				}
				return r;
			},

			/**
			 * # 行列中のそれぞれの最大値のインデックスを取得
			 * @param matrix
			 * @returns {Array}
			 */
			maxIdx(matrix) {
				let r = [];
				for (let i=0,l=matrix.length; i<l; i+=1) {
					r[i] = math.arr.maxIdx(matrix[i]);
				}
				return r;
			},

			/**
			 * # 2つの行列の同じ次元の配列のインデックスの要素の値が同じだった場合に、そのカウント数を配列で取得する
			 * @param m1
			 * @param m2
			 * @returns {Array}
			 */
			matchCount(m1, m2) {
				let r = [];
				for (let i=0,l=m1.length; i<l; i+=1) {
					r[i] = math.arr.matchCount(m1[i], m2[i]);
				}
				return r;
			},

			/**
			 * # 累乗する
			 * @param x
			 * @param n
			 * @returns {*}
			 */
			pow(x, n) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.arr.pow(x[i], n[i]);
				}
				return r;
			},

			/**
			 * # Ex を返す.(自然対数の底であるネイピア数（オイラー数))
			 * @param x
			 * @returns {*}
			 */
			exp(x) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.arr.exp(x[i]);
				}
				return r;
			},

			/**
			 * # 自然対数 (底は e) を返す.
			 * @param x
			 * @returns {*}
			 */
			log(x) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.arr.log(x[i]);
				}
				return r;
			},

			/**
			 * # 一番大きい数値を返す
			 * @param x
			 * @returns {number}
			 */
			max(x) {
				let r = [];
				for (let i=0,l=x.length; i<l; i+=1) {
					r[i] = math.arr.max(x[i]);
				}
				return r;
			},

			/**
			 * # 行列の列を行に変換
			 * @param matrix
			 * @returns {Array}
			 */
			colToRow(matrix) {
				let r = [];
				for (let i=0,l=matrix[0].length; i<l; i+=1) {
					r[i] = [];
					for (let j=0,m=matrix.length; j<m; j+=1) {
						r[i][j] = matrix[j][i];
					}
				}
				return r;
			},

			/**
			 * # 行列の内積を計算
			 * @param m1
			 * @param m2
			 * @returns {*|Array}
			 */
			dot(m1, m2) {
				/**
				 * # 内積計算関数
				 * @param a
				 * @param b
				 * @returns {Array}
				 * @private
				 */
				const _dot = (a, b) => {
					let r = [];
					for (let i=0,l=a.length; i<l; i+=1) {
						r[i] = [];
						for (let j=0,l=b.length; j<l; j+=1) {
							r[i][j] = math.sum(math.multi(a[i], b[j]));
						}
					}
					return r;
				};

				const tmpM1 = m1;
				const tmpM2 = m2;
				let r;

				if ((math.shape(m1)[0]===1) || (math.shape(m2)[0]===1)) { // どちらかの項が1次元配列だった場合にデータを整形
					const a = this.create(m1);
					const b = this.create(m2);
					const bc = this.broadcast(a, b, 0);
					m1 = bc[0];
					m2 = bc[1];

					if (!util.isArray(tmpM1[0])) {
						m2 = this.colToRow(m2);
						r = _dot(m1, m2);
						r = r[0];
					} else if (!util.isArray(tmpM2[0])) {
						r = _dot(m2, m1);
						r = r[0];
					} else {
						throw new Error('内積を計算できません.');
					}
				} else {
					m2 = this.colToRow(m2);
					r = _dot(m1, m2);
				}

				return r;
			}
		}
	};

	// api
	return {
		util: util,
		math: math
	};
};
